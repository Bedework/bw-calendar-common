/* **********************************************************************
    Licensed to Jasig under one or more contributor license
    agreements. See the NOTICE file distributed with this work
    for additional information regarding copyright ownership.
    Jasig licenses this file to you under the Apache License,
    Version 2.0 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a
    copy of the License at:

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on
    an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied. See the License for the
    specific language governing permissions and limitations
    under the License.
*/
package org.bedework.calfacade;

import org.bedework.calfacade.base.ChangeFlag;
import org.bedework.calfacade.base.OverrideList;
import org.bedework.calfacade.base.OverrideSet;
import org.bedework.calfacade.util.CalFacadeUtil;

import java.util.List;
import java.util.Set;

/** <p>DO NOT EDIT THE GENERATED JAVA.
 *
 * <p>The proxy java source is generated based on annotations in the event file.
 * To change the proxy, either make changes to the annotations processing or
 * change the annotations in the event class.
 *
 * <p>An event proxy in Bedework.If an event is an alias or reference to another
 * event, this class holds links to both. The referring event will hold user
 * changes, which override the values in the target.
 *
 * <p>For any collection we need to copy the entire collection into the
 * referring event if a change is made. We need a flag to indicate such changes.
 *
 * <p>We cannot just look at the values in the two objects becuase we have to
 * call the getXXX method to allow the persistance engine to retrieve the
 * collection.
 *
 * <p>We could also remove the current mode, that of creating an empty collection
 * in the get methods when none exists.
 *
 * <p>XXX Incomplete. Some fields we can handle easily (String mostly).
 * Problems still arise with fields like locations and recurrence stuff.
 *
 * @author Mike Douglass
 * @version 1.0
 */
public class BwEventProxy extends BwEvent implements ChangeFlag {
  /** The referring event
   */
  private final BwEventAnnotation ref;

  private boolean changeFlag;

  /** Constructor
   *
   * @param ref the annotation
   */
  public BwEventProxy(final BwEventAnnotation ref) {
    this.ref = ref;
  }

  /* ==========================================================
   *                      Bean methods
   * ========================================================== */

  /** Get referenced event
   *
   * @return  BwEventAnnotation
   */
  public BwEventAnnotation getRef() {
    return ref;
  }

  /** Set the event change flag.
   *
   * @param  val boolean true if event changed.
   */
  public void setChangeFlag(final boolean val) {
    changeFlag = val;
  }

  /** See if the event has changed.
   *
   * @return  boolean   true if event changed.
   */
  public boolean getChangeFlag() {
    if (changeFlag) {
      return true;
    }

    if (!CalFacadeUtil.eqObjval(ref.getDtstart(), getTarget().getDtstart())) {
      changeFlag = true;
      return true;
    }

    if (!CalFacadeUtil.eqObjval(ref.getDtend(), getTarget().getDtend())) {
      changeFlag = true;
      return true;
    }

    return false;
  }

  /** Get the target from the ref
   *
   * @return BwEvent target of reference
   */
  public BwEvent getTarget() {
    return ref.getTarget();
  }

  /* ============================================================
   *                   BwDbentity methods
   * ============================================================ */

  @Override
  public void setId(final int val) {
    throw new RuntimeException("Immutable");
  }

  @Override
  public int getId() {
    return ref.getId();
  }

  @Override
  public void setSeq(final int val) {
    throw new RuntimeException("Immutable");
  }

  @Override
  public int getSeq() {
    return ref.getSeq();
  }

  /* ============================================================
   *                   BwOwnedDbentity methods
   * ============================================================ */

  @Override
  public void setOwnerHref(final String val) {
    if (!CalFacadeUtil.eqObjval(getTarget().getOwnerHref(), val)) {
      ref.setOwnerHref(val);
      setChangeFlag(true);
    }
  }

  @Override
  public String getOwnerHref() {
    return ref.getOwnerHref();
  }

  @Override
  public void setPublick(final Boolean val) {
    /*
    Boolean old = ref.getPublick();
    ref.setPublick(val);

    if (Util.cmpObjval(old, val) != 0) {
      setChangeFlag(true);
    }
    */
    ref.setPublick(val);
    setChangeFlag(true);
  }

  @Override
  public Boolean getPublick() {
    final var val = ref.getPublick();
    if (val != null) {
      return val;
    }

    return getTarget().getPublick();
    //return ref.getPublick();
  }

  @Override
  public void setCreatorHref(final String val) {
    if (!CalFacadeUtil.eqObjval(getTarget().getCreatorHref(), val)) {
      ref.setCreatorHref(val);
      setChangeFlag(true);
    }
  }

  @Override
  public String getCreatorHref() {
    return getTarget().getCreatorHref();
  }

  @Override
  public void setAccess(final String val) {
    if (!CalFacadeUtil.eqObjval(getTarget().getAccess(), val)) {
      ref.setAccess(val);
      setChangeFlag(true);
    }
  }

  @Override
  public String getAccess() {
    if (!ref.getOverride()) {
      // Always comes from the annotation.
      return ref.getAccess();
    }

    final var val = ref.getAccess();
    if (val != null) {
      return val;
    }

    return getTarget().getAccess();
  }

  @Override
  public void setColPath(final String val) {
    ref.setColPath(val);
  }

  @Override
  public String getColPath() {
    final var val = ref.getColPath();
    if (val != null) {
      return val;
    }

    return getTarget().getColPath();
  }

  /* ============================================================
   *                      Start, end and duration methods
   * Currently these are always set in the annotation
   * ============================================================ */

  @Override
  public void setDtstart(final BwDateTime val) {
    if (!CalFacadeUtil.eqObjval(getRef().getDtstart(), val)) {
      ref.setDtstart(val);
      setChangeFlag(true);
    }
  }

  @Override
  public void setDtend(final BwDateTime val) {
    if (!CalFacadeUtil.eqObjval(getRef().getDtend(), val)) {
      ref.setDtend(val);
      setChangeFlag(true);
    }
  }

  @Override
  public void setEndType(final char val) {
    ref.setEndType(val);
    setChangeFlag(true);
  }

  @Override
  public void setDuration(final String val) {
    if (!CalFacadeUtil.eqObjval(getRef().getDuration(), val)) {
      ref.setDuration(val);
      setChangeFlag(true);
    }
  }

  @Override
  public void setNoStart(final Boolean val) {
    if (!CalFacadeUtil.eqObjval(getRef().getNoStart(), val)) {
      ref.setNoStart(val);
      setChangeFlag(true);
    }
  }

  /* ============================================================
   *                  Temp methods until schema change
   * ============================================================ */

  @Override
  public void setOrganizerSchedulingObject(final Boolean val) {
    final var props =
            getXproperties(BwXproperty.bedeworkOrganizerSchedulingObject);
    BwXproperty xp = null;
    if ((props != null) && !props.isEmpty()) {
      xp = props.getFirst();
    }

    if (xp != null) {
      if (val == null) {
        // Delete property
        removeXproperty(xp);
      } else {
        xp.setValue(String.valueOf(val));
      }
    } else if (val != null) {
      addXproperty(new BwXproperty(BwXproperty.bedeworkOrganizerSchedulingObject,
                                   null,
                                   String.valueOf(val)));
    }
  }

  @Override
  public Boolean getOrganizerSchedulingObject() {
    final var val = ref.getXproperty(BwXproperty.bedeworkOrganizerSchedulingObject);
    if (val != null) {
      return Boolean.valueOf(val);
    }

    return getTarget().getOrganizerSchedulingObject();
  }

  @Override
  public void setAttendeeSchedulingObject(final Boolean val) {
    final var props =
            getXproperties(BwXproperty.bedeworkAttendeeSchedulingObject);
    BwXproperty xp = null;
    if ((props != null) && !props.isEmpty()) {
      xp = props.getFirst();
    }

    if (xp != null) {
      if (val == null) {
        // Delete property
        removeXproperty(xp);
      } else {
        xp.setValue(String.valueOf(val));
      }
    } else {
      addXproperty(new BwXproperty(BwXproperty.bedeworkAttendeeSchedulingObject,
                                   null,
                                   String.valueOf(val)));
    }
  }

  @Override
  public Boolean getAttendeeSchedulingObject() {
    final var val = ref.getXproperty(BwXproperty.bedeworkAttendeeSchedulingObject);
    if (val != null) {
      return Boolean.valueOf(val);
    }

    return getTarget().getAttendeeSchedulingObject();
  }

  /* ============================================================
   *                      Bean methods
   * ============================================================ */

++++++++++++++++++++++++++++++++++++++++++++++++++ Code inserted here

  /* ============================================================
   *                   Recurrence Helper methods
   * ============================================================ */

  @Override
  public boolean hasRrules() {
    return ref.hasRrules() || getTarget().hasRrules();
  }

  @Override
  public boolean hasExrules() {
    return ref.hasExrules() || getTarget().hasExrules();
  }

  /* ============================================================
   *                   Convenience methods
   * ============================================================ */

  @Override
  public void updateLastmod() {
    ref.updateLastmod();
  }

  @Override
  public void updateDtstamp() {
    ref.updateDtstamp();
  }

  /* ============================================================
   *                           Factory methods
   * ============================================================ */

  /** Creates an annotation object for the given event then returns a proxy
   * object to handle it.
   *
   * @param ev  BwEvent object to annotate
   * @param ownerHref identifies owner
   * @param forInstance      true if this is an overrride or a recurrence instance
   * @return BwEventProxy object
   */
  public static BwEventProxy makeAnnotation(final BwEvent ev,
                                            final String ownerHref,
                                            final boolean forInstance) {
    final var ann = new BwEventAnnotation();

    initAnnotation(ann, ev, ownerHref, forInstance);

    return new BwEventProxy(ann);
  }

  /** Initialise an annotation object from the given event.
   *
   * @param ann  The annotation object
   * @param ev  BwEvent object to annotate
   * @param ownerHref  if null event owner is used
   * @param forInstance      true if this is an overrride or a recurrence instance
   */
  public static void initAnnotation(final BwEventAnnotation ann,
                                    final BwEvent ev,
                                    final String ownerHref,
                                    final boolean forInstance) {
    ann.setTarget(ev);

    /* XXX This should be a parameter */
    ann.setMaster(ev);

    final var start = ev.getDtstart();
    final var end = ev.getDtend();

    ann.setDtstart(start);
    ann.setDtend(end);
    //ann.setDuration(BwDateTime.makeDuration(start, end).toString());
    ann.setDuration(ev.getDuration());
    ann.setEndType(ev.getEndType());
    ann.setCreatorHref(ev.getCreatorHref());
    ann.setUid(ev.getUid());
    ann.setName(ev.getName());
    ann.setOverride(forInstance);

    if (forInstance) {
      // Same calendar as master
      ann.setColPath(ev.getColPath());
    }

    if (ownerHref != null) {
      ann.setOwnerHref(ownerHref);
    } else {
      ann.setOwnerHref(ev.getOwnerHref());
    }
  }

  /* ============================================================
   *                   Recurrence update and query methods
   * ============================================================ */

  public BwDuration makeDurationBean() {
    String duration = ref.getDuration();
    if (duration == null) {
      duration = getTarget().getDuration();
    }
    return BwDuration.makeDuration(duration);
  }

  /* ============================================================
   *                   Object methods
   * ============================================================ */

  public String toString() {
    return new StringBuilder("BwEventProxy{")
            .append(ref.toString())
            .append("}")
            .toString();
  }

  /** When cloning a proxy we generally need to point the cloned annotation at
   * a new target and master.
   *
   * @param master new master for override
   * @param target new target for override
   * @return cloned proxy.
   */
  public BwEventProxy clone(final BwEvent master,
                            final BwEvent target) {
    final var ann = (BwEventAnnotation)ref.clone();

    ann.setMaster(master);
    ann.setTarget(target);

    return new BwEventProxy(ann);
  }

  public Object clone() {
    return new BwEventProxy((BwEventAnnotation)ref.clone());
  }

  /* ============================================================
   *                   private methods
   * ============================================================ */

  private static final int setNoChange = 0;
  private static final int setRefNull = 1;   // call ref.setMMM(null)
  private static final int setRefVal = 2;   // call ref.setMMM(val)
  private static final int setChanged = 3;  // All changes done

  private int doSet(final ProxiedFieldIndex pfi,
                    final boolean immutable,
                    final Object masterVal,
                    final Object refVal,
                    final Object newVal) {
    int res = setNoChange;

    if (CalFacadeUtil.eqObjval(masterVal, newVal)) {
      // ref = target - turn off any override
      if (ref.getEmptyFlag(pfi)) {
        ref .setEmptyFlag(pfi, false);
        res = setChanged;
      }

      if (refVal != null) {
        res = setRefNull;
      }

      if (res != setNoChange) {
        setChangeFlag(true);
      }

      return res;
    }

    /* The new value is different from the master value - we are overriding */

    if (immutable) {
      // We let if get this far as cloning can result in a set call that does
      // nothing
      throw new RuntimeException("Immutable");
    }

    if (newVal == null) {
      // Setting override to null

      if (!ref.getEmptyFlag(pfi)) {
        ref .setEmptyFlag(pfi, true);
        res = setRefNull;
        setChangeFlag(true);
      }

      return res;
    }

    // Setting an override value

    if (ref.getEmptyFlag(pfi)) {
      ref.setEmptyFlag(pfi, false);
      setChangeFlag(true);
    }

    if (CalFacadeUtil.eqObjval(refVal, newVal)) {
      return setNoChange; // Nothing further to do
    }

    setChangeFlag(true);

    return setRefVal;
  }
}
